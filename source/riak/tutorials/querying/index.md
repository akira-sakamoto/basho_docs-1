---
title: Querying Riak
project: riak
version: 0.10.0+
document: tutorials
toc: true
audience: beginner
keywords: [mapreduce, search, indexes, comparison]
next: [[基本操作|Basic Operations]]
---

* [[基本操作|Basic Operations]]
* [[Map Reduce]]
* [[セカンダリインデックス|Secondary Indexes]]
* [[検索する|Riak Search]]

## MapReduce、RiakSearch、セカンダリインデックスの比較

&nbsp; | MapReduce | Riak Search | セカンダリインデックス
-------|----------|-------------|------------------
*クエリの種類* | 任意の数の Map フェーズと Reduce フェーズからなる、一時的なクエリ | 全文検索、ワイルドカード、近接、ブール演算の組み合わせ使用可能な SQLR スタイルのクエリ | 一致および範囲クエリ対応
*インデックスの局所性* | N/A | 語句のインデックスは N 個の vnode (語句を基準に分類) にレプリケーションされ、Riak KV が使用しているバックエンドとは関係なく、マージ インデックス バックエンドに保存される | インデックスはオブジェクトとして、同じ vnode (ドキュメントを基準に分類) にあり、ドキュメントの一緒に LevelDB バックエンドに保存される
*クエリされる Vnode* | 入力に依存、クエリ1回につき1語句; ワイルドカードがあると 1/N | リクエストごとに全 KV vnode の 1/N
*対応データタイプ* | Erlang MapReduce 関数を使い、あらゆるデータタイプに対応; JavaScript 関数では UTF8 JSON も可。指定ごとに [[リンク|Links]] される | 整数、日付、テキスト | バイナリおよび整数
*エクストラクト* | Map フェーズでは、次の Map フェーズおよび Reduce フェーズ用にデータをエクストラクト可能 | トークン化は用意されているアナライザ(Whitespace、Standard、Integer、Non-Op) のいずれか、あるいはカスタムアナライザによって行われる | インデックス化された値はオブジェクトのメタデータとして与えられ、アプリケーションがトークン化を行う
*アンチ・エントロピー / フォールトトレランス* | N/A | 検索するパーティションがロスト、あるいは壊れている場合、Riak Console の "repair" 機能によって、隣接のインデックスからパーティションデータを再構築 | アンチ・エントロピー機能は KV から引き継いでいる; パーティションがロストした場合、読み出し修復機能によって KV とともにセカンダリインデックスが再構築される
*制限* | MapReduce 操作はメモリ上で実行され、タイムアウト時間までに完了しなければならない | 頻度の低い語句をクエリすると vnode の一部に負荷をかける; 複合クエリは高コストとなる; ドキュメントは構造化(JSON または XML)されるか、プレインテキストでなければならない | LevelDB バックエンドでのみ有効; 複合検索不可
*望ましい使用例* | 既知のバケット・キー ペアに対してクエリを行う場合 | オブジェクトを全文検索する場合 | 特定の語句でタグ付けされたオブジェクトをすべて検索する場合
*望ましくない使用例* | 大量のオブジェクトに対して複合検索を行う(バケット内の全オブジェクトを解析する) | ドキュメント内の一般的な語句 (頻度が低い) の検索 | 自由文の検索
