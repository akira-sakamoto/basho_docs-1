---
title: Riak 基本 API の操作
project: riak
version: 0.10.0+
document: tutorial
audience: beginner
keywords: [tutorial, fast-track]
prev: ["Building a Dev Environment", "Building-a-Development-Environment.html"]
up:   ["The Riak Fast Track", "index.html"]
next: ["MapReduce Queries", "Loading-Data-and-Running-MapReduce-Queries.html"]
---

このモジュールでは、Riak HTTP API を使用します。

## オブジェクト/キー操作

Riak はデータをバケット、キー、バリューとして管理します。バリュー(またはオブジェクト)はユニークなキーで識別され、各キー/バリュー ペアはバケットに格納されます。バケットは基本的に Riak 内のフラットなネームスペースです。複数のバケットに同一のキーネームを許したり、バケットごとにレプリケーションファクタや、pre/post-commit フックを設定する、ということにはあまり意味はありません。

Riak での操作のほとんどが、キーのバリューをセットするか、取得することです。このセクションでは、Riak HTTP API をどのように使うのかを説明します。また、Erlan、Java、PHP、Python、Ruby、C/C++ 用に[[サポートされているクライアントライブラリ|Client Libraries]]についても説明します。さらに[[コミュニティでサポートしているプロジェクト|Community Developed Libraries and Projects]]として、.NET、Node.js、Python(および Twisted)、Griffon、Small Talk、Perl、Scala、Clojure、その他もろもろがあります。

### 必要な知識

* *Client ID* - すべてのリクエストには *X-Riak-ClientId* ヘッダを含むべきで、これはクライアントをユニークに識別できるいかなる文字列でも構いません。[[ベクタークロック|Riak Glossary#Vercor Clock]] でオブジェクトの変化を追跡するのに使用します。
* *URL Escaping* - バケット、キー、リンク指定には、エスケープなしのスラッシュを含めてはいけません。URSエスケープ ライブラリを使うか、スラッシュを %2F に置き換えてください。

### オブジェクトを読む

バケットから指定したキーを取得するときは、このようになります。

```bash
GET /riak/bucket/key
```

レスポンスのボディにはオブジェクトの内容が含まれます(もしあれば)。

Riak は content-type ネゴシエーションの *Accept* のような、多くの HTTP 定義のヘッダを認識します。siblings を取り扱うときは、[[HTTP API における sibling のサンプル|HTTP Fetch Object#Siblings examples]] を、さらに条件つきリクエストには *If-None-Mach*/*ETag*、*If-Modified-Since*/*Last-Modified* を参照してください。

Riak はさまざまなクエリパラメータも受け付けます。GET リクエストにおける R-value は *r* で設定します(R value というのは、オブジェクトを取得する際に、レスポンスが成功するにはなんこのレプリカの一致が必要かを示すものです。R value については、Fast Track チュートリアルの最後のセクションで詳しく説明します)。*r* クエリパラメータを省略すると、Riak はデフォルトの *r=2* を採用します。

正常時のレスポンスコード:

* *200 OK*
* *300 Multiple Choices*
* *304 Not Modified*

主なエラーコード:

* *404 Not Found*

早い話、このコマンドを試してみてください。これは "test" というバケットから "doc2" というキーをリクエスト(GET)します。

```bash
$ curl -v http://127.0.0.1:8091/riak/test/doc2
```

ここでは *404 Not Found* が返り、"doc2" というキーがない(まだ作っていませんから！)ことを示します。

### 既存、またはユーザ定義のキーでオブジェクトを格納する

アプリケーションはしばしば、独自の方法でデータのキーを生成します。このとき、データの格納は簡単です。リクエストはこのようになります。

```bash
PUT /riak/bucket/key
```

<div class="info"><code>POST</code> は互換性のために残されている、有効な動詞です。</div>

キーを追加すると、バケットが自動的に作成されることに注意してください。バケットを明示的に "create" する必要はありません(バケットおよびそのプロパティについては、このページの後のほうで説明します)。

PUT にはリクエストヘッダが必要です:

* *Content-Type* は、オブジェクトを格納するためにセットしなければなりません。次回のリクエストでどのような形で受け取りたいのかをセットします。
* *X-Riak-Vclock* オブジェクトがすでに存在すれば、読み出しの際にベクタークロックが付加されます。新規オブジェクトの場合は、このヘッダは無視されます。

その他のリクエストヘッダはオプションです:

* *X-Riak-Meta-_YourHeader_* オブジェクトと共に格納できる任意のメタデータ ヘッダです。
* *Link* ユーザおよびシステム定義済みの、他のリソースへのリンクです。[[リンク|links]] についての詳細。

GET リクエストでの "r" クエリパラメータと同様に、PUT リクエストでもこれらのパラメータをサポートしています:

* *r* 書き込みの前にオブジェクトを取得するとき、何個のレプリカが一致する必要があるか(整数値、デフォルトは 2)
* *w* 成功のレスポンスを返す前に何個のレプリカへ書きこむか(整数値、デフォルトは 2)
* *dw* 成功のレスポンスを返す前に何個のレプリカを耐久記憶として保証するか(整数値、デフォルトは 0)
* *returnbody* 格納されているオブジェクトのコンテンツを返すか否か(ブーリアン文字列、デフォルトは "false")

正常時のステータスコード:

* *200 OK*
* *204 No Content*
* *300 Multiple Choices*

*returnbody=true* のとき、GET リクエストではなんらかのレスポンスへっだがあることを期待しています。siblings があったとき、あるいは操作の結果生成されたとき、レスポンスが同じだったときには GET リクエストのように、*300 Multiple Choices* を返します。

それではここで、ターミナルで試してみましょう。


```bash
$ curl -v -XPUT -d '{"bar":"baz"}' -H "Content-Type: application/json" \
  -H "X-Riak-Vclock: a85hYGBgzGDKBVIszMk55zKYEhnzWBlKIniO8mUBAA==" \
  http://127.0.0.1:8091/riak/test/doc?returnbody=true
```

### Store a new object and assign random key

If your application would rather leave key-generation up to Riak, issue a POST request to the bucket URL instead of a PUT to a bucket/key pair:

```bash
POST /riak/bucket
```

If you don't pass Riak a "key" name after the bucket, it will know to create one for you.

Supported headers are the same as for bucket/key PUT requests, though *X-Riak-Vclock* will never be relevant for these POST requests.  Supported query parameters are also the same as for bucket/key PUT requests.

Normal status codes:

* *201 Created*

This command will store an object, in the bucket "test" and assign it a key:

```bash
$ curl -v -d 'this is a test' -H "Content-Type: text/plain" \
  http://127.0.0.1:8091/riak/test
```

In the output, the *Location* header will give the you key for that object. To view the newly created object, go to `http://127.0.0.1:8091/*_Location_*` in your browser.

If you've done it correctly, you should see the value (which is "this is a test").

### Delete an object

Lastly, you'll need to know how to delete keys.

The command, as you can probably guess, follows a predictable pattern and looks like this:

```bash
DELETE /riak/bucket/key
```

The normal response codes for a DELETE operations are *204 No Content* and *404 Not Found*

404 responses are "normal" in the sense that DELETE operations are idempotent and not finding the resource has the same effect as deleting it.

Try this:

```bash
$ curl -v -X DELETE http://127.0.0.1:8091/riak/test/test2
```

## Bucket Properties and Operations

Buckets are essentially a flat namespace in Riak. They allow the same key name to exist in multiple buckets and provide some per-bucket configurability.

<div class="info"><div class="title">How Many Buckets Can I Have?</div>
Currently, buckets come with virtually no cost except for when you modify the default bucket properties. Modified Bucket properties are gossiped around the cluster and therefore add to the amount of data sent around the network. In other words, buckets using the default bucket properties are free.
</div>

### Setting a bucket's properties

There is no need to "create" buckets in Riak.  They pop into existence when keys are added to them, and dissappear when all keys have been removed from them.

However, in addition to providing a namespace for keys, the properties of a bucket also define some of the behaviors that Riak will implement for the values stored in the bucket.

To set these properties, issue a PUT to the bucket's URL:

```bash
PUT /riak/bucket
```

The body of the request should be a JSON object with a single entry "props."  Unmodified bucket properties may be omitted.

Important headers:

* Content-Type: *application/json*

The most important properties to consider for your bucket are:

* *n_val* - the number of replicas for objects in this bucket (defaults to 3); *n_val* should be an integer greater than 0 and less than the number of partitions in the ring.

<div class="note">Changing *n_val* after keys have been added to the bucket is not advisable as it may result in failed reads because the new value may not be replicated to all the appropriate partitions.</div>

* *allow_mult* - _true_ or _false_ (defaults to _false_ ); Riak maintains any sibling objects caused by things like concurrent writes or network partitions. With *allow_mult* set to false, clients will only get the most-recent-by-timestamp object.

Let's go ahead and alter the properties of a Bucket. The following PUT will create a new bucket called "test" with a modified n_val of 5.

```bash
$ curl -v -XPUT -H "Content-Type: application/json" -d '{"props":{"n_val":5}}' \
  http://127.0.0.1:8091/riak/test
```

### GET Buckets

Here is how you use the HTTP API to retrieve (or "GET") the bucket properties and/or keys:

```bash
GET /riak/bucket_name
```

Again, quite simple. (Are you starting to see a pattern?)

The optional query parameters are:

* *props=true|false* - whether to return the bucket properties (defaults to "true")
* *keys=true|false|stream* - whether to return the keys stored in the bucket (defaults to "false"); see the [[HTTP API's list keys|HTTP List Keys]] for details about dealing with a *keys=stream* response


With that in mind, go ahead and run this command. This will GET the bucket information that we just set with the sample command above:


```bash
$ curl -v http://127.0.0.1:8091/riak/test
```

You can also view this Bucket information through any browser by going to `http://127.0.0.1:8091/riak/test`

So, that's the basics of how the HTTP API works. An in depth reading of the HTTP API page (linked below) is highly recommended. This will give you details on the headers, parameters, and status that you should keep in mind when using the HTTP Interface. 


<div class="title">Additional Reading for this Section</div>

* [[The HTTP API In Depth|HTTP API]]
* [[Protocol Buffers API|PBC API]]
* [[Replication in Depth|Replication]]
* [Why Vector Clocks are Easy](http://blog.basho.com/2010/01/29/why-vector-clocks-are-easy/)
* [Why Vector Clocks are Hard](http://blog.basho.com/2010/04/05/why-vector-clocks-are-hard/)

